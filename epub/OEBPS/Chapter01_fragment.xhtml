<?xml version="1.0" encoding="utf-8"?>
        <!DOCTYPE html>

        <html xmlns="http://www.w3.org/1999/xhtml">
        <head>
          <title>Chapter 1</title>
          <link rel="stylesheet" href="styles/pygments.css" type="text/css" />
          <link rel="stylesheet" href="styles/softcover.css" type="text/css" />
          <link rel="stylesheet" href="styles/epub.css" type="text/css" />
          <link rel="stylesheet" href="styles/custom.css" type="text/css"/>
          <link rel="stylesheet" href="styles/custom_epub.css" type="text/css"/>
          <link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="styles/page-template.xpgt" />
        </head>

        <body>
          <div id="cid1" class="chapter"><h1><a href="Chapter01_fragment.xhtml#cid1" class="heading hyperref"><span class="number">Chapter 1 </span>How I got started with Puppet and Devops ?</a></h1>
<p class="noindent">As Georg Buchner said:</p>
<blockquote class="quotation"><p class="quote">We are only puppets, our strings
are being pulled by unknown forces.<span class="intersentencespace"></span></p>
</blockquote><p>My journey with Puppet began back in 2008, when as I was part of the Ops Team managing web scale infrastructure for a SaaS company.<span class="intersentencespace"></span> Our team consisted of ops engineers in India and US working out of their respective timezones, keeping lights on 24x7.<span class="intersentencespace"></span> As part of day to day operations, all of us would make ad hoc changes to the servers, and not always communicate back with the team on the other side of the globe.<span class="intersentencespace"></span> We did not have daily sync up meetings either.<span class="intersentencespace"></span> As a result of this ad hoc, inconsistent setup, regularly, issues would pop up with the product, in pre production/integration as well as in production environments.<span class="intersentencespace"></span> Being in charge of triaging, my team would spend a lot of time flipping through logs, doing root cause analysis and figuring out whether its a problem due to inconsistent configurations or a actual code related issue.<span class="intersentencespace"></span> Tired of this fire fighting, we started looking for solutions to help us efficiently manage this environment.<span class="intersentencespace"></span> And thats when we came across Puppet, which was popular, was already picked by likes of google, and had an active community around it.<span class="intersentencespace"></span> We started using it to setup the infrastructure as well as manage changes through a centralized console.</p>
<p>Results were immediate, and tangible.<span class="intersentencespace"></span> After implementing puppet based configuration management system,</p>
<ul>
<li>We now had a centralized tool which streamlined our process of managing configurations.<span class="intersentencespace"></span> This resulted in minimal ad hoc changes and <strong>consistency</strong> across the environments.<span class="intersentencespace"></span>
</li>
<li><strong>Visibility</strong> was another important outcome.<span class="intersentencespace"></span> Since we started writing infrastructure as a Code, everyone including the developers had <strong>visibility</strong> into the way infrastructure was configured.<span class="intersentencespace"></span> All one had to do was look at the svn/git repository, the last commits to know what changes were made, my whom and when.<span class="intersentencespace"></span> What more, developers could even tweak the application properties in their own integration environments.<span class="intersentencespace"></span>
</li>
<li><strong>Error rates</strong>, specially related to configurations dropped significantly, giving us more time back in our day, to focus on scale and other important issues.<span class="intersentencespace"></span>
</li></ul>
<p>That was the beginning of my journey with devops automation tools, which also includes exposure to Chef, and Ansible.<span class="intersentencespace"></span> Puppet was the first kid on the block, and has come a long way from the time it was created by <strong>Luke Kanies</strong> along with initial developers in 2005, to become a very matured and a indispensable tool in the kitty of a devops engineer.</p>
<p>Before we start looking into what makes puppet a excellent choice for a automation tool, lets first understand what configuration management is about.</p>
</div><div id="cid2" class="section"><h2><a href="Chapter01_fragment.xhtml#cid2" class="heading hyperref"><span class="number">1.1 </span>Infrastructure Life Events and Puppet</a></h2>
<p class="noindent">If you are the one who is in the business of managing more than a handful of systems, you should be familiar with the term “Configuration Management” (not to confuse with traditional Software Configuration Management or SCM).<span class="intersentencespace"></span> Be it physical servers, virtual machines or cloud based setup, infrastructure typically goes through the following life events,</p>
<div class="graphics image"><img src="https://raw.githubusercontent.com/initcron/book-puppet-fundamentals/master/manuscript/images/chapter1/infra_lifecycle.png" alt="https://raw" /></div>
<ul>
<li><strong>Provisioning</strong>
<ul>
<li>Provision servers - physical, virtual or cloud.<span class="intersentencespace"></span> This is where the servers are brought into being.<span class="intersentencespace"></span>
</li>
<li>Install Operating System either using manual/automated install process or using an image/template.<span class="intersentencespace"></span>
</li></ul>
</li>
<li><strong>Configuration Management</strong>
<ul>
<li>Base Systems Configurations: Prepare the systems with the base configurations such as users, packages, security configurations, network setup etc.<span class="intersentencespace"></span>
</li>
<li>Tech Stack: install and configure services such as apache, tomcat, middle wares, setup cron jobs, install and configure databases etc.<span class="intersentencespace"></span>
</li>
<li>Application: Deploy the application code on top of the tech stack configured.<span class="intersentencespace"></span> This is where the code written by your team gets deployed with relevant configurations.<span class="intersentencespace"></span>
</li></ul>
</li>
<li><strong>Change Management</strong>
Configurations made during the initial setup do not remain do not last for a life time.<span class="intersentencespace"></span> Infrastructure is in the constant state of flux and evolves over time.<span class="intersentencespace"></span> Change management involves,
<ul>
<li>Updating configurations parameters across a class of servers eg.<span class="intersentencespace"></span> update port that web server is running on.<span class="intersentencespace"></span>
</li>
<li>Deploying new versions of the application code, push security patches etc, install additional services.<span class="intersentencespace"></span>
</li></ul>
</li></ul>
<p>Puppet serves as a excellent tool for Configuration Management as well as Change Management.<span class="intersentencespace"></span> And along with tools such as Razor, Cloud Plugins, Vagrant, Terraform it could also automate provisioning of servers too.<span class="intersentencespace"></span> However puppet as a tool by itself does have an ability to provision and comes in to play once the Operating System is installed and puppet agent is setup.</p>
<p>If you are looking for a tool which could also provision servers, and do it effectively, you should consider Ansible.</p>
</div><div id="cid3" class="section"><h2><a href="Chapter01_fragment.xhtml#cid3" class="heading hyperref"><span class="number">1.2 </span>Evolution of Configuration Management</a></h2>
<p class="noindent">The need for managing configurations and ongoing changes had been a challenge which has seen various approaches.<span class="intersentencespace"></span> Lets have a look at the evolution of configuration management,</p>
<div id="uid14" class="subsection"><h3><a href="Chapter01_fragment.xhtml#uid14" class="heading hyperref"><span class="number">1.2.1 </span>Manual</a></h3>
<p class="noindent">As systems engineers, we almost always begin configuring systems by hand, in a ad hoc manner.<span class="intersentencespace"></span> This approach is the easiest, and useful when you have only a handful of systems to manage, simple configurations, and where you do not have repeatable tasks or updates.<span class="intersentencespace"></span> However, as you start growing, this crude approach quickly gets out of control.<span class="intersentencespace"></span> It also involves manual processes, which mandates a operator to be present, and is prone to errors or omissions.</p>
</div>
<div id="uid15" class="subsection"><h3><a href="Chapter01_fragment.xhtml#uid15" class="heading hyperref"><span class="number">1.2.2 </span>Scripts</a></h3>
<p class="noindent">Scripts allow one to take a sequence of commands to run and put it in a procedural program.<span class="intersentencespace"></span> Whenever there is need to repeat the process, scripts come in very handy.<span class="intersentencespace"></span> Some of the popular scripting languages amongst the systems personnel include shell/bash, perl, python, ruby or powershell.<span class="intersentencespace"></span> Scripts are almost always the first approach towards automating manual tasks.<span class="intersentencespace"></span> However, scripts are not scalable or flexible enough to manage a sophisticated infrastructure spanning across multitude of environments or the ones involving multiple different operating systems etc.</p>
</div>
<div id="uid16" class="subsection"><h3><a href="Chapter01_fragment.xhtml#uid16" class="heading hyperref"><span class="number">1.2.3 </span>Configuration Management and Software Configuration Management</a></h3>
<p class="noindent">Software Configuration Management is referred to often with context of
Revision Control which is about tracking changes to the application code.<span class="intersentencespace"></span> This is just one part of a larger field of Configuration Management.</p>
</div>
<div id="uid17" class="subsection"><h3><a href="Chapter01_fragment.xhtml#uid17" class="heading hyperref"><span class="number">1.2.4 </span>Golden Images/ Templates</a></h3>
<p class="noindent">Golden images, or templates, or simply os images, are probably the quickest way to deploy servers complete with configurations, specially in virtual or cloud environments.<span class="intersentencespace"></span> Images are nothing but pre baked templates with operations system files, applications, and configurations.<span class="intersentencespace"></span> Take any cloud provider, and one of the first components to choose while you provision a server is the images.<span class="intersentencespace"></span> A lot of organizations these days package their products in the form of images such as ova, vmdk or even vagrant’s box format.<span class="intersentencespace"></span> However images have one major problem i.e.<span class="intersentencespace"></span> change management.<span class="intersentencespace"></span> Every time there is an update, even a single line change, one needs to build a new image.<span class="intersentencespace"></span> Not only this complete system image needs to be distributed but also existing systems need to be replaced with the new image.<span class="intersentencespace"></span> Imagine doing that in a dynamic environment involving frequent updates across hundreds of servers.<span class="intersentencespace"></span> That could get too cumbersome.<span class="intersentencespace"></span> And thats where the need to come up with a new approach.</p>
</div>
<div id="uid18" class="subsection"><h3><a href="Chapter01_fragment.xhtml#uid18" class="heading hyperref"><span class="number">1.2.5 </span>Infrastructure as a Code</a></h3>
<p class="noindent">“Infrastructure as a Code” or “Programmable Infrastructure” is where today’s generation tools such as Puppet, Chef, Ansible, Salt fit in.<span class="intersentencespace"></span> These tools essentially allow one to write the state of the infrastructure using a higher level descriptive language and store it as a code.<span class="intersentencespace"></span> Since this is a code, one could bring in the best practices that developers have been following for years e.g.<span class="intersentencespace"></span> using revision control systems, use of sophisticated editors, test driven development, peer programming etc.<span class="intersentencespace"></span> You could even build the complete infrastructure from scratch in case of a disaster, as long as you have the code repository, compute resources and data backups in place.<span class="intersentencespace"></span> Since this code is written in a simple declarative syntax, it is self documenting and offers visibility to all stakeholders into the way infrastructure is built and configured.</p>
<div class="graphics image"><img src="https://raw.githubusercontent.com/initcron/book-puppet-fundamentals/master/manuscript/images/chapter1/config_mgmt_approaches.png" alt="https://raw" /></div>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Approach</td>
<td class="align_left right_border">Advantages</td>
<td class="align_left right_border">Disadvantages</td>
</tr><tr><td class="left_border align_left right_border">Manual</td>
<td class="align_left right_border">simple</td>
<td class="align_left right_border">ad hoc, error prone, inconsistent, not repeatable</td>
</tr><tr><td class="left_border align_left right_border">Scripts</td>
<td class="align_left right_border">repeatable, automated</td>
<td class="align_left right_border">procedural, not scalable, inflexible</td>
</tr><tr><td class="left_border align_left right_border">Images</td>
<td class="align_left right_border">repeatable, automated</td>
<td class="align_left right_border">size, change management is not easy</td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border">Infrastructure as a Code</td>
<td class="align_left right_border">repeatable, flexible, scalable, automated, consistent</td>
<td class="align_left right_border">agent based, learning curve</td>
</tr></table>
</div></div><div id="cid4" class="section"><h2><a href="Chapter01_fragment.xhtml#cid4" class="heading hyperref"><span class="number">1.3 </span>Why to use Puppet ?</a></h2>
<p class="noindent">Now that we have started discussion on Infrastructure as a Code, specifically Puppet, lets discuss about the specific features of puppet that make it a useful tool for configuration and change management.</p>
</div><div id="cid5" class="section"><h2><a href="Chapter01_fragment.xhtml#cid5" class="heading hyperref"><span class="number">1.4 </span>Declarative vs Procedural Approach</a></h2>
<p class="noindent">Scripts take a procedural approach towards automation.<span class="intersentencespace"></span> With scripts, we focus on the <strong>how</strong> part.<span class="intersentencespace"></span> e.g.<span class="intersentencespace"></span> how to install a package, how to create a user, how to modify it later, how to do it on a specific platform.<span class="intersentencespace"></span> And if you would want to add a support for another platform, you may have to add additional procedure and write a conditional to check for the platform and call the relevant code.<span class="intersentencespace"></span> This involves a lot of efforts.</p>
<p>On the other hand, Puppet takes a declarative approach towards automation.<span class="intersentencespace"></span> With Puppet, our focus changes from <strong>how</strong> part to <strong>what</strong>.<span class="intersentencespace"></span> Instead of writing procedures, we start using a simple declarative syntax to define the desired state of infrastructure.<span class="intersentencespace"></span> Let me explain this with an analogy.</p>
<p>Lets say we want to build a house.<span class="intersentencespace"></span> When we set out to do so, we hire a contractor, who in turns has a team of construction workers who know how to build it brick by brick.<span class="intersentencespace"></span> They do all the hard work to bring our house into a reality.<span class="intersentencespace"></span> Thats the <em>how</em> part.</p>
<p>On the other hand, you have a Architect.<span class="intersentencespace"></span> Lets take a moment and think about what he or she does.<span class="intersentencespace"></span> An Architect creates a plan, a blue print, which is nothing but a description of how your house should look like.<span class="intersentencespace"></span> The architect envisions the end state of your house, thinks about <em>what</em> should it consists of, breaks it down into components, and starts creating specification for each.<span class="intersentencespace"></span> He would then stitch it together to create a blueprint of our house, and hands it to the contractor to go and build it.<span class="intersentencespace"></span> This is the how part.</p>
<p>Thats exactly what we would start doing with puppet, only difference being, we write the specification for desired state of IT infrastructure.</p>
</div><div id="cid6" class="section"><h2><a href="Chapter01_fragment.xhtml#cid6" class="heading hyperref"><span class="number">1.5 </span>Resource Abstraction Layer</a></h2>
<p class="noindent">We just learnt about puppet allowing us to write the desired state of the infrastructure using a descriptive language.<span class="intersentencespace"></span> Now this concept is brought into a reality with the its Domain Specific Language(DSL) which consists of a Resource Abstraction Layer (RAL).<span class="intersentencespace"></span> Lets describe how this works,</p>
<p><em>TODO</em>: Create an image for each step below.</p>
<ul>
<li>Puppet looks at infrastructure as a collection of entities to manage e.g.<span class="intersentencespace"></span> package, service, user, network interface etc.<span class="intersentencespace"></span>
</li>
<li>It then takes the procedures, the actual logic to manage these entities and bundles it into something called as <strong>Providers</strong>.<span class="intersentencespace"></span> Providers are platform specific.<span class="intersentencespace"></span> That way, each entity may have multiple providers e.g.<span class="intersentencespace"></span> managing user on linux vs osx vs windows.<span class="intersentencespace"></span>
</li>
<li>On top of these procedures, puppet creates an abstraction layer.<span class="intersentencespace"></span> Instead of defining the procedures, it offers the users a simple declarative syntax to define the state of the entity and its properties, in the form of <strong>Resources</strong>.<span class="intersentencespace"></span>
</li>
<li>Puppet, then does the translation between Resources and Providers, and calls the procedure to put the entity in to the desired state just as described by the user.<span class="intersentencespace"></span>
</li></ul>
<p>This behavior allows the users of the puppet to create policies stating what which entities should be present or absent, with what properties.</p>
</div><div id="cid7" class="section"><h2><a href="Chapter01_fragment.xhtml#cid7" class="heading hyperref"><span class="number">1.6 </span>Convergence and Idempotence</a></h2>
<p class="noindent">Puppet reads the resources, calls the relevant providers for the platform it runs on, and ensures the desired state of the resource is achieved.<span class="intersentencespace"></span> While it does so, it may need to make changes to the system.<span class="intersentencespace"></span> But what if the resource has already achieved the desired state and needs no further updates?<span class="intersentencespace"></span> Puppet has the built in intelligence to know what is the current state of the resource is.<span class="intersentencespace"></span> Instead of making changes blindly, it first compares the current state of the resource with the desired state, and the makes a decision whether it requires any changes, and if yes, what changes to make.<span class="intersentencespace"></span> This process is called as convergence.</p>
<p><em>TODO</em>: Draw diagrams, maybe just a flowchart</p>
<p>e.g.</p>
<p>Lets assume we have written a resource to create a user with a password.</p>
<div class="code"><div class="highlight"><pre>user{'xyz':
  uid       =&gt;  '501',
  gid       =&gt;  '501',
  home      =&gt;  '/home/xyz',
  password  =&gt;  '$1$foYKL0zO$elXbUOb/JjHqS4aI8O25i.'
}
</pre></div></div>
<ul>
<li>First time puppet applies this resource on the system, the user may not exist.<span class="intersentencespace"></span> Puppet detects the current state, compares it with the desired state which mentions it should exist, and finds the configuration drift.<span class="intersentencespace"></span> It then creates the user with the password to bring the current state to desired state.<span class="intersentencespace"></span>
</li>
<li>Lets assume we run puppet again to apply the same resource.<span class="intersentencespace"></span> This time too it will compare the desired state with current state.<span class="intersentencespace"></span> Since the user is already present with the password provided, it deems no changes necessary.<span class="intersentencespace"></span> Instead of attempting to create the user again, it will skip the resource and move on to the next one.<span class="intersentencespace"></span>
</li>
<li>Lets assume we updated the password information for the user in our code description of the resource, and excute puppet.<span class="intersentencespace"></span> This time, while comparing the current state with desired state, it detects that the user is present, but the password is updated.<span class="intersentencespace"></span> It does not attempt to create a user, but only changes one property i.e.<span class="intersentencespace"></span> password.<span class="intersentencespace"></span>
</li></ul>
<p>Idempotence is a useful property to ensures that puppet maintains the state of the infrastructure such that its always in the policy.<span class="intersentencespace"></span> This also makes change management easier as one could keep running puppet as a service which invokes itself at regular intervals, pulls the changes, and apply only what is changed.</p>
</div><div id="cid8" class="section"><h2><a href="Chapter01_fragment.xhtml#cid8" class="heading hyperref"><span class="number">1.7 </span>Centralized Configuration Management System</a></h2>
<p class="noindent">A typical installation of puppet involves a Puppet Master, which is a centralized management console and Agents runnings on every node managed.<span class="intersentencespace"></span> Any changes to nodes have to go through the Puppet Master.<span class="intersentencespace"></span> This streamlines the process of pushing updated.<span class="intersentencespace"></span> Instead of iterating over a list of hosts using a for loop or other such methods, or logging into each system to make changes, all you need to do is push updates to Puppet Master, from where those are automatically propogated to the nodes.</p>
<p><em>TODO</em> <span rend="inline" file="images/"></span></p>
<div id="uid26" class="subsection"><h3><a href="Chapter01_fragment.xhtml#uid26" class="heading hyperref"><span class="number">1.7.1 </span>Pull Approach</a></h3>
<p class="noindent">While puppet offers a centralized management approach, it works unlike most client server schemes.<span class="intersentencespace"></span> Instead of pushing updates to the nodes from master, its the duty of puppet agent to go the master, pull changes, and apply.<span class="intersentencespace"></span> Pull method offers more flexibility and scalability for the following reasons,</p>
<ul>
<li>Each node could decide how frequently or infrequently it should update.<span class="intersentencespace"></span> Some systems need frequent updates, where as others need not be updated for weeks.<span class="intersentencespace"></span> This could be controlled at per client level.<span class="intersentencespace"></span>
</li>
<li>No need to manage inventory and connection details on the master.<span class="intersentencespace"></span> Nodes could come and go, and could be configured based on dynamic rules to classify them based on certain property e.g.<span class="intersentencespace"></span> host names, environments, or even hardware addresses.<span class="intersentencespace"></span>
</li>
<li>With push based approach, master must have a ability reach out and connect to each node managed in order to configure it.<span class="intersentencespace"></span> A lot of times you may have a master on a cloud or in a separate data center than nodes being managed, which could be behind a firewall or NAT device in a private network.<span class="intersentencespace"></span> In case of pull method, as long as the master is available on a well known address, and is reachable from the nodes, configurations can be pulled and applied.<span class="intersentencespace"></span>
</li></ul>
</div></div><div id="cid9" class="section"><h2><a href="Chapter01_fragment.xhtml#cid9" class="heading hyperref"><span class="number">1.8 </span>Code vs Data</a></h2>
<p class="noindent">A lot of applications that we configure on our servers are generic eg.<span class="intersentencespace"></span> apache, tomcat, mysql, mongo.<span class="intersentencespace"></span> These applications have a install base of hundreds of thousands of servers, used by organizations across the globe.<span class="intersentencespace"></span> Ever wondered how these become specific to your environment ?<span class="intersentencespace"></span> Even though you use the same apache web server used by many others, its how you configure it makes the difference.<span class="intersentencespace"></span> Even in single organization, you may have a apache server which behaves differently in different environment based on the configuration profile created.<span class="intersentencespace"></span> The process of setting up an application involves,</p>
<ul>
<li>Installing the generic application either from a source, package or a repository.<span class="intersentencespace"></span>
</li>
<li>Adding data.<span class="intersentencespace"></span> This where you set configuration parameters e.g.<span class="intersentencespace"></span> port, user, max connections, webroot for apache.<span class="intersentencespace"></span>
</li>
<li>Start, enable the service.<span class="intersentencespace"></span>
</li></ul>
<p>Puppet allows separation of code and data.</p>
<ul>
<li>Using Puppet’s DSL, we write infrastructure code to install packages start services etc.<span class="intersentencespace"></span> Code is generic.<span class="intersentencespace"></span>
</li>
<li>Puppet’s variables/parameters/facts, scopes, templates, along with tools such as Hiera and ENC provide a way to create different configuration profiles specific to different nodes, environments, platforms etc.<span class="intersentencespace"></span>
</li></ul>
</div><div id="cid10" class="section"><h2><a href="Chapter01_fragment.xhtml#cid10" class="heading hyperref"><span class="number">1.9 </span>Shared Library of Infrastructure Code</a></h2>
<p class="noindent">With puppet’s ability to separate code and configuration data, the declarative code that you write in the form of modules with puppet becomes generic enough to be shared and be reused.<span class="intersentencespace"></span> And since this code is in the version control, hosted services such as github offer the perfect means to publish this code.<span class="intersentencespace"></span> As you start writing code with puppet, you would discover about puppet forge, a library of community written modules.<span class="intersentencespace"></span> At the time of writing, there are more than 4000 modules available on puppet forge.<span class="intersentencespace"></span> Similar to a lot of open source code, you need not re invent the wheel.<span class="intersentencespace"></span> For most open source applications, you would find very sophisticated modules which you could use without even single line change.<span class="intersentencespace"></span> Download the modules, install it on your own puppet master, add configuration profile, and off you go.</p>
</div><div id="cid11" class="section"><h2><a href="Chapter01_fragment.xhtml#cid11" class="heading hyperref"><span class="number">1.10 </span>Cloud Integrations</a></h2>
<p class="noindent">With emergence of cloud, computing is moving towards the utility model.<span class="intersentencespace"></span> More and more organizations have already migrated or contemplating to migrate a partial or whole of their computing setup to cloud.<span class="intersentencespace"></span> And with that happening, which ever automation tool that you would consider, needs to have a close integration with the cloud platform that you plan to use.<span class="intersentencespace"></span> Provisioning of infrastructure components before puppet comes in and starts configuring There are two ways Puppet provides a way for this,</p>
<ol>
<li>Through library of custom resources/libraries which allow one to write provisioning of cloud components in the form of resources.<span class="intersentencespace"></span>
</li>
<li>Cloud specific tools e.g.<span class="intersentencespace"></span> Cloudformation on AWS or Heat on Openstack are some of the tools which help provision components which are specific to that cloud and then call puppet to do the configurations.<span class="intersentencespace"></span>
</li>
<li>Third party tools such as Vagrant, Terraform have in turn ability to talk to multiple cloud providers.<span class="intersentencespace"></span> These tools typically provision servers on the cloud and then hand it off to puppet for configurations.<span class="intersentencespace"></span>
</li></ol>
</div><div id="cid12" class="section"><h2><a href="Chapter01_fragment.xhtml#cid12" class="heading hyperref"><span class="number">1.11 </span>Iterative Approach to Automation</a></h2>
<p class="noindent">However convinced you are with Puppet, scrapping your existing automation tool overnight for a shiny new tool may have unknown risks attached.<span class="intersentencespace"></span> More over, it may could be challenging to get a buy in from your management to invest in time, money and resources to implement a new solution without showing them the value.</p>
<p>With puppet, you could take a iterative approach towards automation.<span class="intersentencespace"></span> You could start with a single application, or even a single entity such as a system user to manage.<span class="intersentencespace"></span> Once you see the value, show it to all stake holders, get a buy in and move to the next application, one at a time.</p>
</div><div id="cid13" class="section"><h2><a href="Chapter01_fragment.xhtml#cid13" class="heading hyperref"><span class="number">1.12 </span>Device Support</a></h2>
<p class="noindent">Managing configurations on systems running common operating systems such as windows, linux, os x, where puppet agent application can be installed is easy.<span class="intersentencespace"></span> Its a completely different beast when it comes to managing configurations on devices running their own specialized version of operating systems/firmwares.<span class="intersentencespace"></span> Examples are configuring CISCO’s network switches routers, EMC’s storage array.</p>
<p>Along with programmable infrastructures, new concepts such as Software Defined Networking(SDN) and Software Defined Storage(SDS) are taking root and changing the way devices are being managed.<span class="intersentencespace"></span> Puppet supports managing devices in two ways,</p>
<ol>
<li>Devices that are based on linux and have puppet agent ported to run on those can be configured the same way as other generic systems.<span class="intersentencespace"></span>
</li>
<li>Sub set of devices that do not have puppet agent can still be configured with puppet’s device support over ssh/telnet.<span class="intersentencespace"></span> For such devices, puppet uses push instead of pull approach.<span class="intersentencespace"></span>
</li></ol>
</div><div id="cid14" class="section"><h2><a href="Chapter01_fragment.xhtml#cid14" class="heading hyperref"><span class="number">1.13 </span>Audit and Compliance</a></h2>
<p class="noindent">With ability to define the state of the infrastructure components as a code and then converge, one could easily codify the infrastructure policies and have them enforced.<span class="intersentencespace"></span> Puppets ability to test, log changes, and reporting mechanisms help keeping a trail of the state of the systems and its components over time and track who made changes, when, if there are any nodes which have fallen out of policy etc.</p>
</div><div id="cid15" class="section"><h2><a href="Chapter01_fragment.xhtml#cid15" class="heading hyperref"><span class="number">1.14 </span>When to Use Puppet ?</a></h2>
<p class="noindent">You should consider using puppet for the following purposes,</p>
<ul>
<li><strong>Configuration Management</strong> + Change Management: You have many nodes to deploy with changes happening often.<span class="intersentencespace"></span> You need to update the nodes and applications running on those often.<span class="intersentencespace"></span>
</li>
<li><strong>Compliance and Audit</strong>: When your organization has to comply to policies and you need an ability to convert those policies into a code which would auto correct and bring the nodes into the policy in case of configuration drifts.<span class="intersentencespace"></span> You also need to audit the systems regularly and prepare reports to find out which nodes have drifted away from the policy etc.<span class="intersentencespace"></span> as well as mitigate such issues.<span class="intersentencespace"></span>
</li>
<li><strong>Software Delivery</strong> : If you are in business of building software and delivering as ova images or similar, puppet is better approach to deliver the product and push updates to it.<span class="intersentencespace"></span>
</li></ul>
</div><div id="cid16" class="section"><h2><a href="Chapter01_fragment.xhtml#cid16" class="heading hyperref"><span class="number">1.15 </span>Who is it for?</a></h2>
<ul>
<li>Systems Administrators/Engineers who are managing systems at scale and need to install, configure, patch, monitor and maintain systems and prepared reports for.<span class="intersentencespace"></span>
</li>
<li>Application Operations Engineers who are responsible for installing, configuring, integrating, monitoring, maintaining application infrastructures.<span class="intersentencespace"></span>
</li>
<li>Build and release engineers who are in charge of setting up environments for CI/CD cycles, as well as deploy/release applications to production environments.<span class="intersentencespace"></span>
</li>
<li>Network Engineers who configure and maintain networking devices such as CISCO Routers and Switches at scale.<span class="intersentencespace"></span>
</li>
<li>Storage Administrators who configure and maintain storage devices.<span class="intersentencespace"></span>
</li>
<li>Developers who are building application delivery to their customers.<span class="intersentencespace"></span> Also as users of the develops tools, developers may need to change application properties for the environments that they create/use.<span class="intersentencespace"></span>
</li></ul>
</div><div id="cid17" class="section"><h2><a href="Chapter01_fragment.xhtml#cid17" class="heading hyperref"><span class="number">1.16 </span>What Puppet is not?</a></h2>
<ul>
<li>Graphical Management Tool (e.g.<span class="intersentencespace"></span> SCCM):
If you are looking for a tool which would allow you to manage everything through a graphical interface without writing any code or without ever having to use an editor, well puppet is not the tool for you.<span class="intersentencespace"></span> I have come across many engineers, who say “well, the capabilities of puppet sounds great, but can I do all of this using a GUI where I can just click click and get things done….<span class="intersentencespace"></span> ? “ Well, its infrastructure as a code is what we are talking about.<span class="intersentencespace"></span> Even though enterprise puppet puppet offers a nice GUI, its mostly for reporting and classifications.<span class="intersentencespace"></span> Since I started using puppet and similar tools, I have been using text editors more often.
<ul>
<li>Automated Testing Tool ( e.g.<span class="intersentencespace"></span> selenium ):
Its not a silver bullet.<span class="intersentencespace"></span> Its not one solutions to all.<span class="intersentencespace"></span> I meet a lot of QA folks who have heard that puppet would automate everything and you could use it for testing too.<span class="intersentencespace"></span> Well, there is always a special purpose tool for each task and the application testing is not puppet’s ball game.<span class="intersentencespace"></span> Sure puppet could help in testing by letting you automate the process of building and configuring a fresh environment to run your tests inside, and give you ability to do it repeatedly.<span class="intersentencespace"></span> It also gives you a way to test infrastrcuture code.<span class="intersentencespace"></span> However, its not a test automation tool.<span class="intersentencespace"></span>
</li>
<li>Pure Application Deployment and Orchestration Tool:
Even though Puppet has been talking about application orchestration, if you are looking for a tool purely for application deployments, rolling updates, canary releases, orchestrated deployments over multiple hosts, you have tools which do it better.<span class="intersentencespace"></span> A few tools I could suggest you for application deployment and orchestration are Asible, Capistrano, Code Deploy which are push based, and work better in such scenarios.<span class="intersentencespace"></span>
</li>
<li>Agent less Management System:
Except for a sub set of network devices, puppet mandates running agents on each node being managed.<span class="intersentencespace"></span> In fact its designed to be heavy on the agent side which is responsible to initiate communication with the master, pull policies, enforce and report back.<span class="intersentencespace"></span> If you need a agent less management system, puppet is not the one.<span class="intersentencespace"></span> Again, I would suggest using Ansible in such cases, which works over ssh and is agent less.<span class="intersentencespace"></span>
</li>
<li>Software Configuration Management(SCM) Tool
SCM is a part of the larger Configuration Management and typically refers to the practice of revision/version control.<span class="intersentencespace"></span> Puppet is not the tool which does the version control, however it can be used to replicate and manage software configurations across a cluster of nodes.<span class="intersentencespace"></span>
</li>
<li>A one stop Devops solutions
</li>
<li>Puppet Use Cases/ Customer Stories
</li></ul>
</li></ul>
</div><div id="cid18" class="section"><h2><a href="Chapter01_fragment.xhtml#cid18" class="heading hyperref"><span class="number">1.17 </span>Puppet vs Chef</a></h2>
</div><div id="cid19" class="section"><h2><a href="Chapter01_fragment.xhtml#cid19" class="heading hyperref"><span class="number">1.18 </span>Puppet vs Ansible</a></h2>
</div><div id="cid20" class="section"><h2><a href="Chapter01_fragment.xhtml#cid20" class="heading hyperref"><span class="number">1.19 </span>Puppet vs Docker</a></h2>
</div><div id="cid21" class="section"><h2><a href="Chapter01_fragment.xhtml#cid21" class="heading hyperref"><span class="number">1.20 </span>Upgrading from Puppet 3 to Puppet 4</a></h2>
</div><div id="cid22" class="section"><h2><a href="Chapter01_fragment.xhtml#cid22" class="heading hyperref"><span class="number">1.21 </span>Using Tidy to clean up unwanted files</a></h2>
</div>
        </body>
        </html>